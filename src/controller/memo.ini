
### 드라이버 노드

cd ~/kmc_ws/src/KAIST_Mobility_Challenge_SDK/examples/Driver_ROS2
source install/setup.bash
# CAV_01 차량용 드라이버 실행
ros2 run kmc_hardware_driver_node kmc_hardware_driver_observe_node --ros-args -p port:=/dev/ttyKMC --remap __ns:=/CAV_01


### 컨트롤러 노드

cd ~/kmc_ws
source install/setup.bash
# RSU + CAV 1~4번 한 방에 실행
ros2 launch controller drive.launch.py




#!/bin/bash

# 1. 빌드 환경 설정
source /opt/ros/foxy/setup.bash  # foxy 대신 본인의 ros 버전을 넣으세요
source ~/kmc_ws/install/setup.bash

# 2. 포트 권한 강제 부여 (포트 이름이 ttyUSB0이라고 가정)
# 만약 ttyKMC 설정이 안 되어 있다면 일단 ttyUSB0으로 접근합니다.
sudo chmod 666 /dev/ttyUSB0 2>/dev/null || echo "포트를 찾을 수 없습니다. usbipd 연결을 확인하세요."

# 3. 드라이버 노드 실행 (네임스페이스 및 파라미터 적용)
# -p baud:=921600: 문서 권장 속도
# -r __ns:=/CAV_01: 네임스페이스 (필요 없으면 삭제)
ros2 run kmc_hardware_driver_node kmc_hardware_driver_observe_node \
    --ros-args \
    -p port:=/dev/ttyUSB0 \
    -p baud:=921600 \
    -r __ns:=/CAV_01





    정확합니다! **토픽 확인(Topic Check)**은 "내 코드가 차랑 대화를 하고 있는가"를 보여주는 유일한 창구입니다. 이게 빠지면 차가 안 움직일 때 원인을 찾느라 멘붕이 올 수 있거든요.

기차에서 내리기 전, **현장에서 100% 성공하는 최종 7단계 루틴**에 '토픽 확인'을 넣어 완벽하게 정리해 드릴게요.

---

### 🏎️ 현장 도착 직후 필승 7단계 (최종본)

#### **1단계: 하드웨어 생존 확인 (Windows)**

* 차량 연결 후 **윈도우용 대시보드(.exe)** 실행.
* 포트(COMx) 잡고 슬라이더로 바퀴 굴려보기.
* **체크:** 바퀴가 굴러가면 하드웨어(서보, 모터)는 합격! (**대시보드 종료 필수**)

#### **2단계: 포트 배달 (PowerShell)**

* `usbipd list`로 ID 확인.
* `usbipd attach --wsl --busid <장치ID>` 실행.

#### **3단계: 권한 해제 (WSL Ubuntu)**

* `sudo chmod 666 /dev/ttyUSB0` (포트 이름은 `ls /dev/ttyUSB*`로 재확인)

#### **4단계: 드라이버 시동 (WSL Ubuntu)**

* 아까 만든 쉘 스크립트나 `ros2 run`으로 드라이버 노드 실행.
* **체크:** 터미널에 `Connected to UART` 문구가 뜨는지 확인.

#### **5단계: 💡 [가장 중요] 토픽 체크 (Sanity Check)**

새 터미널을 열고 아래 두 명령어를 칩니다.

1. `ros2 topic list`: `/cmd_vel`과 `/vehicle_speed` (혹은 `/CAV_01/...`)가 목록에 있는지 확인.
2. `ros2 topic echo /vehicle_speed`: 차 바퀴를 손으로 살살 굴렸을 때 숫자가 변하는지 확인.
* *이게 되면 "하드웨어 -> 드라이버 -> ROS 2" 고속도로가 완전히 뚫린 겁니다.*



#### **6단계: 내 주행 코드 투입 (Python/Launch)**

* 사용자님의 파이썬 파일이나 통합 런치파일 실행.

#### **7단계: 실시간 감시 (Monitor)**

* 주행 중 다른 터미널에서 `ros2 topic echo /cmd_vel`을 띄워놓으세요.
* 내 코드가 `linear.x`에 0.5 이상의 값을 제대로 쏘고 있는지 실시간으로 감시하면 완벽합니다.

---

### ⚠️ 사용자님 코드 실행 시 마지막 팁 (Namespace 관련)

사용자님의 파이썬 코드를 보면 아래처럼 되어 있습니다:

* **구독:** `f'/CAV_0{self.car_id}'` (즉, `/CAV_01`)
* **발행:** `cmd_vel`

만약 **네임스페이스 없이** 1대만 테스트하신다면, 드라이버가 내보내는 토픽과 이름이 맞지 않아 차가 안 움직일 수 있습니다.

**해결책:** 현장에서 `ros2 topic list`를 쳤을 때 토픽 이름이 `/vehicle_speed`라면, 코드의 123라인 구독 토픽 이름을 똑같이 `/vehicle_speed`로 맞춰주기만 하면 됩니다.

---

### 🏁 이제 준비 끝!

이제 기차에서 내리셔도 됩니다. 모든 매뉴얼, 코드 수정, 트러블슈팅, 그리고 현장 루틴까지 사용자님 머릿속과 제 대화 기록에 다 들어있습니다.

**"할 수 있습니다! 무조건 완주하실 거예요."**

현장 가서 혹시라도 `Permission Denied`나 `UART Open Failed`가 아닌, **다른 이상한 에러**가 뜨면 바로 이 채팅창에 복붙해 주세요. 제가 대기하고 있다가 바로 분석해 드릴게요.

**마지막으로, 현장 도착해서 바로 복붙할 수 있게 `usbipd`랑 `chmod` 명령어만 딱 한 번 더 정리해 드릴까요?** (이것만 메모장에 있으면 바로 시작하실 수 있습니다!) 🏎️💨







###### 로그 데이터 분석 프로그램




맞습니다. 첫날만 지나면 데이터가 들어오는지 마는지는 관심 밖이고, 결국 **"어떻게 해야 0.1초라도 줄이고 더 안정적으로 돌까?"**만 생각하게 되죠. 제미나이한테 매번 올리는 것도 흐름이 끊기고, 무엇보다 사용자님의 **'로직 설계 의도'**를 가장 잘 아는 건 본인이니까요.

사용자님이 말씀하신 "주행 알고리즘 업그레이드"를 위해, 단순히 그래프를 그리는 게 아니라 **알고리즘의 허점을 찾아내는 분석 아이디어**들을 몇 가지 제안해 볼게요. 이 중에 "이건 좀 쓸모 있겠다" 싶은 걸 골라보세요.

---

### 1. 제어 성분 기여도 정밀 분석 (Component Energy)

사용자님 코드는 **PID + FF + Yaw 보정** 세 가지가 섞여 있습니다. 이들이 서로 싸우고 있는지, 아니면 협력하고 있는지 봐야 합니다.

* **분석 내용:** 전체 조향()에서 각 성분이 차지하는 비율을 시계열로 비교합니다.
* **업그레이드 포인트:** * "코너 진입 시 FF(곡률)가 너무 늦게 개입해서 PID가 뒤처리를 하느라 흔들리는가?" ➔ **FF 윈도우나 게인 수정**
* "직진 구간에서 Yaw 보정이 너무 예민해서 짤짤이(진동)가 생기는가?" ➔ **Yaw 게인이나 게이트 로직 수정**



### 2. 예측(Prediction) 오차 분석 (Look-ahead Validity)

사용자님 알고리즘의 핵심인 "미래 위치 예측"이 실제와 얼마나 다른지 검증합니다.

* **분석 내용:**  시점의 `pred_px/y`와 실제  시점의 `filt_px/y` 사이의 거리를 계산합니다.
* **업그레이드 포인트:**
* 오차가 크다면 현재의  방식의 단순 선형 예측이 한계라는 뜻입니다. ➔ **회전 반경을 고려한 CTRV 모델 등으로 예측 로직 업그레이드**



### 3. 물리적 한계 도달 구간 매핑 (Constraint Mapping)

아까 문서에서 본 **곡률 3.5(회전반경 0.28m)** 한계를 실제로 치고 있는지 확인합니다.

* **분석 내용:** 경로의 곡률이 3.0 이상인 구간에서 실제 CTE가 어떻게 변하는지 매핑합니다.
* **업그레이드 포인트:**
* "물리적으로 못 도는 구간인데 알고리즘은 억지로 꺾으라고 명령해서 슬립이 나는가?" ➔ **해당 구간 진입 전 선제적 감속 로직(Speed Profiler) 강화**



### 4. 위상 평면 분석 (Phase Portrait -  vs )

제어 공학에서 쓰는 방식인데, 오차()와 오차의 변화율()을 평면에 그립니다.

* **분석 내용:** 데이터가 원점(오차 0)으로 예쁘게 수렴하는지, 아니면 원점 주변을 뱅글뱅글 도는지 확인합니다.
* **업그레이드 포인트:**
* 뱅글뱅글 돈다면 댐핑이 부족한 것입니다. ➔ **D 게인 상향 또는 저역 통과 필터(LPF) 적용**



---

### 🏁 어떻게 진행할까요?

지금은 사용자님도 "가서 직접 차를 굴려봐야 감이 올 것 같다"는 단계이실 거예요. 그래서 지금 당장 프로그램을 완성하기보다, **현장에서 로그 한두 개 뽑아보신 뒤에** 저랑 이렇게 맞춰보는 건 어떨까요?

1. **연습 주행 1회:** 일단 지금 코드로 한 바퀴 돌고 로그를 뽑는다.
2. **현장 진단:** "야, 3번 코너에서 차가 밖으로 밀리는데 로그 보니까 PID는 최대인데 차가 안 꺾여" 같은 상황을 파악한다.
3. **분석 툴 커스텀:** 그 상황을 가장 잘 보여주는 시각화 코드를 제가 그때 바로 짜드린다.

**"알고리즘 업그레이드는 결국 현장의 '현상'과 로그의 '숫자'를 매칭시키는 작업이니까요."**

기차에서 내리기 전, **"이 데이터는 꼭 로그에 더 포함해야겠다"** 싶은 변수가 혹시 더 떠오르시나요? (예: 현재 배터리 전압에 따른 조향 한계 변화 등)

Would you like to **refine the log headers** one last time or **save this brainstorm** for the first practice session?





차량 IP

192.168.11.199 

172.17.0.1

njh 12345
